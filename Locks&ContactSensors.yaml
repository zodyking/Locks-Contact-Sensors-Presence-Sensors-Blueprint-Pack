blueprint:
  name: "Aqara: Locks & Contact Sensors"
  description: |-
    ![Aqara](https://raw.githubusercontent.com/zodyking/Aqara-Lock---Sensor-Blueprint/refs/heads/main/image1.png)

    Automates a smart lock using a door contact sensor with optional spoken announcements.
    Built for reliability and clear speech.

    What it does
    • Auto-locks the door X seconds after the sensor reports CLOSED (single, reliable guard).
    • Cancels the lock if the sensor re-opens during the delay window.
    • Speaks OPENED/CLOSED and LOCKED/UNLOCKED (only after real, confirmed state changes).
    • Optional reminders: repeats a message every X seconds while the door is OPEN
      and/or the lock is UNLOCKED, until it’s resolved (stops immediately when fixed).
    • Optional actions: turn on entities when the door opens; turn off entities when the door closes;
      turn on/off entities when the lock UNLOCKS.
    • All speech is queued (mode: queued, max: 2) and a small TTS pre-roll prevents clipped words.

    Setup
    1) Select the contact sensor and the lock.
    2) Choose a TTS engine (e.g., tts.piper) and one or more media_player targets.
    3) Set Auto-lock delay to your preference.
    4) (Optional) Pick announcement mode, pick reminder mode and interval, and/or select optional actions.

    Notes
    • The spoken “room” name comes from the entity’s Area (Settings → Areas). Assign your devices to Areas for natural phrases.
    • Lock announcements trigger only when the lock actually reports locked/unlocked (with a brief confirmation).
    • Works with Aqara and other standard Home Assistant binary_sensor/lock entities.

  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door)
      description: |-
        Pick the contact sensor for THIS door.
        For most Aqara sensors, ON = open and OFF = closed.
        Device class should be door or opening.
      selector:
        entity:
          domain: binary_sensor
          device_class: [door, opening]

    lock_entity:
      name: Smart lock
      description: Pick the lock entity to control (Aqara or any lock.*).
      selector:
        entity:
          domain: lock

    door_type:
      name: Door type (affects default TTS wording)
      description: |-
        Controls how the default TTS refers to the opening (used with the Area name):
          • Standard → “<room> door was <action>”
          • Closet   → “<room> closet door was <action>”
          • Entrance → “<room> entrance door was <action>”
      default: standard
      selector:
        select:
          mode: dropdown
          options: [standard, closet, entrance]

    lock_delay:
      name: Auto-lock delay (seconds)
      description: How long after the sensor first reports CLOSED to attempt locking.
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    # ----- Announcements (mutually exclusive) -----
    announce_mode:
      name: Announcements
      description: |-
        Choose **one** thing to announce:
          • **none** – no speech  
          • **sensor** – announce “<room> door was opened/closed” (based on your door sensor)  
          • **lock** – announce “<room> door was locked/unlocked” (based on your lock)  
        Requires a TTS engine and speakers. Only one can be active at a time.
      default: none
      selector:
        select:
          mode: dropdown
          options: [none, sensor, lock]

    # ----- Reminders (mutually exclusive) -----
    reminder_mode:
      name: Reminder mode
      description: |-
        Choose **one** reminder loop to run, using the interval below:
          • **none** – no reminders  
          • **open** – repeat “<room> door is still open” while the sensor stays OPEN  
          • **unlocked** – repeat “<room> door is still unlocked” while the lock stays UNLOCKED  
        Reminders stop immediately when the condition clears.
      default: none
      selector:
        select:
          mode: dropdown
          options: [none, open, unlocked]

    reminder_interval:
      name: Reminder interval (seconds)
      description: How often to repeat reminder messages while the condition stays true.
      default: 30
      selector:
        number:
          min: 15
          max: 120
          unit_of_measurement: seconds
          mode: slider

    # ----- Optional actions on door/lock events -----
    open_turn_on_entities:
      name: Turn on when door opens (optional)
      description: Select lights/switches to turn on immediately when the door opens.
      default: []
      selector:
        entity:
          multiple: true
          domain: [light, switch]

    close_turn_off_entities:
      name: Turn off when door closes (optional)
      description: Select lights/switches to turn off immediately when the door closes.
      default: []
      selector:
        entity:
          multiple: true
          domain: [light, switch]

    unlock_turn_on_entities:
      name: Turn on when lock UNLOCKS (optional)
      description: Select lights/switches to turn on when the lock becomes UNLOCKED.
      default: []
      selector:
        entity:
          multiple: true
          domain: [light, switch]

    unlock_turn_off_entities:
      name: Turn off when lock UNLOCKS (optional)
      description: Select lights/switches to turn off when the lock becomes UNLOCKED.
      default: []
      selector:
        entity:
          multiple: true
          domain: [light, switch]

    # ----- TTS plumbing -----
    tts_engine:
      name: TTS engine
      description: Pick your TTS engine entity (e.g., tts.piper). Required if any announcements/reminders are enabled.
      default: ""
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: One or more media_player entities to speak on.
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: Let Home Assistant cache synthesized speech when supported.
      default: false
      selector: { boolean: {} }

    tts_voice:
      name: Voice name (optional)
      description: Only used by engines that support an 'options.voice' parameter (Piper, Edge TTS, Amazon Polly, Google Cloud, ElevenLabs). Leave blank otherwise.
      default: ""
      selector: { text: {} }

    tts_preroll_ms:
      name: TTS pre-roll (milliseconds)
      description: Short delay before speaking to avoid clipping the start of the message.
      default: 150
      selector:
        number:
          min: 0
          max: 300
          step: 10
          unit_of_measurement: ms
          mode: slider

    tts_volume:
      name: TTS volume (%)
      description: Volume level to set on all speakers right BEFORE every TTS message (0–100).
      default: 60
      selector:
        number:
          min: 0
          max: 100
          step: 1
          unit_of_measurement: "%"

mode: queued
max: 2

trigger:
  - id: sensor_opened
    platform: state
    entity_id: !input door_sensor
    to: "on"

  - id: sensor_closed
    platform: state
    entity_id: !input door_sensor
    to: "off"

  - id: lock_changed
    platform: state
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity

      # Area → room labels
      sensor_area: "{{ area_name(sensor_ent) }}"
      lock_area: "{{ area_name(lock_ent) }}"
      room_for_sensor: "{{ sensor_area or lock_area or 'Door' }}"
      room_for_lock:   "{{ lock_area or sensor_area or 'Door' }}"

      # Door type → nouning
      door_type_in: !input door_type

      subject_sensor: >-
        {% set r = room_for_sensor %}
        {% set t = (door_type_in or 'standard') %}
        {% if t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}
      subject_lock: >-
        {% set r = room_for_lock %}
        {% set t = (door_type_in or 'standard') %}
        {% if t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}

      # TTS & controls
      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      tts_preroll_ms: !input tts_preroll_ms
      tts_volume_percent: !input tts_volume
      tts_volume_level: "{{ (tts_volume_percent | int) / 100 }}"
      has_tts: >-
        {{ (players | length > 0)
           and (tts_engine_ent is string and (tts_engine_ent | length) > 0) }}

      # Provider detection (safe)
      tts_provider: >-
        {% set s = (tts_engine_ent | string) %}
        {% set p = s.split('.') %}
        {{ p[1] if p|length > 1 else '' }}
      use_voice_option: >-
        {{ (tts_voice_name | default('') | trim) != ''
           and tts_provider in ['piper','edge_tts','amazon_polly','polly','google_cloud','elevenlabs'] }}

      # Mutually-exclusive modes
      announce_mode: !input announce_mode
      reminder_mode: !input reminder_mode
      do_tts_sensor: "{{ has_tts and announce_mode == 'sensor' }}"
      do_tts_lock: "{{ has_tts and announce_mode == 'lock' }}"
      do_tts_open_reminder: "{{ has_tts and reminder_mode == 'open' }}"
      do_tts_unlocked_reminder: "{{ has_tts and reminder_mode == 'unlocked' }}"

      # Optional action targets
      open_turn_on_entities: !input open_turn_on_entities
      close_turn_off_entities: !input close_turn_off_entities
      unlock_turn_on_entities: !input unlock_turn_on_entities
      unlock_turn_off_entities: !input unlock_turn_off_entities

      reminder_interval: !input reminder_interval

      # Messages
      final_opened: "{{ subject_sensor ~ ' was opened.' }}"
      final_closed: "{{ subject_sensor ~ ' was closed.' }}"
      final_locked: "{{ subject_lock ~ ' was locked.' }}"
      final_unlocked: "{{ subject_lock ~ ' was unlocked.' }}"
      final_open_reminder: "{{ subject_sensor ~ ' is still open.' }}"
      final_unlocked_reminder: "{{ subject_lock ~ ' is still unlocked.' }}"

  - choose:

      # ---------- SENSOR OPENED ----------
      - conditions: [{ condition: trigger, id: sensor_opened }]
        sequence:
          # Optional: turn on entities on open
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (open_turn_on_entities | length) > 0 }}"
                sequence:
                  - service: homeassistant.turn_on
                    target: { entity_id: !input open_turn_on_entities }
            default: []

          # Speak OPENED
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                  - service: media_player.volume_set
                    target: { entity_id: !input media_players }
                    data: { volume_level: "{{ tts_volume_level }}" }
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ use_voice_option }}" }]
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_opened }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_opened }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Repeat reminder while OPEN
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_open_reminder }}"
                sequence:
                  - repeat:
                      while:
                        - condition: template
                          value_template: "{{ states(sensor_ent) == 'on' }}"
                      sequence:
                        - wait_for_trigger:
                            - platform: state
                              entity_id: !input door_sensor
                              to: "off"
                          timeout: { seconds: !input reminder_interval }
                          continue_on_timeout: true
                        - condition: template
                          value_template: "{{ states(sensor_ent) == 'on' }}"
                        - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                        - service: media_player.volume_set
                          target: { entity_id: !input media_players }
                          data: { volume_level: "{{ tts_volume_level }}" }
                        - choose:
                            - conditions: [{ condition: template, value_template: "{{ use_voice_option }}" }]
                              sequence:
                                - service: tts.speak
                                  target: { entity_id: !input tts_engine }
                                  data:
                                    message: "{{ final_open_reminder }}"
                                    cache: !input tts_cache
                                    media_player_entity_id: !input media_players
                                    options: { voice: !input tts_voice }
                          default:
                            - service: tts.speak
                              target: { entity_id: !input tts_engine }
                              data:
                                message: "{{ final_open_reminder }}"
                                cache: !input tts_cache
                                media_player_entity_id: !input media_players
            default: []

      # ---------- SENSOR CLOSED (speak, then reliable auto-lock) ----------
      - conditions: [{ condition: trigger, id: sensor_closed }]
        sequence:
          # Optional: turn off entities on close
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (close_turn_off_entities | length) > 0 }}"
                sequence:
                  - service: homeassistant.turn_off
                    target: { entity_id: !input close_turn_off_entities }
            default: []

          # Speak CLOSED
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                  - service: media_player.volume_set
                    target: { entity_id: !input media_players }
                    data: { volume_level: "{{ tts_volume_level }}" }
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ use_voice_option }}" }]
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_closed }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_closed }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Wait delay unless the door re-opens → then cancel
          - wait_for_trigger:
              - platform: state
                entity_id: !input door_sensor
                to: "on"
            timeout: { seconds: !input lock_delay }
            continue_on_timeout: true
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait.completed | default(false) }}"
                sequence:
                  - stop: "Door reopened during delay; cancel auto-lock."
            default: []
          - condition: template
            value_template: "{{ states(sensor_ent) != 'on' }}"
          - service: lock.lock
            target: { entity_id: !input lock_entity }

      # ---------- LOCK CHANGED (only locked/unlocked) ----------
      - conditions: [{ condition: trigger, id: lock_changed }]
        sequence:
          # Optional: turn on entities on UNLOCK
          - choose:
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ (unlock_turn_on_entities | length) > 0
                         and trigger.to_state.state == 'unlocked' }}
                sequence:
                  - service: homeassistant.turn_on
                    target: { entity_id: !input unlock_turn_on_entities }
            default: []

          # Optional: turn off entities on UNLOCK
          - choose:
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ (unlock_turn_off_entities | length) > 0
                         and trigger.to_state.state == 'unlocked' }}
                sequence:
                  - service: homeassistant.turn_off
                    target: { entity_id: !input unlock_turn_off_entities }
            default: []

          # Speak LOCKED/UNLOCKED
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_lock and trigger.to_state.state in ['locked','unlocked'] }}"
                sequence:
                  - delay: { milliseconds: 150 }
                  - condition: template
                    value_template: "{{ is_state(lock_ent, trigger.to_state.state) }}"
                  - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                  - service: media_player.volume_set
                    target: { entity_id: !input media_players }
                    data: { volume_level: "{{ tts_volume_level }}" }
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ use_voice_option }}" }]
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: >-
                                {% if trigger.to_state.state == 'locked' %}
                                  {{ final_locked }}
                                {% else %}
                                  {{ final_unlocked }}
                                {% endif %}
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% if trigger.to_state.state == 'locked' %}
                              {{ final_locked }}
                            {% else %}
                              {{ final_unlocked }}
                            {% endif %}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Repeat reminder while UNLOCKED
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_unlocked_reminder and trigger.to_state.state == 'unlocked' }}"
                sequence:
                  - repeat:
                      while:
                        - condition: template
                          value_template: "{{ states(lock_ent) == 'unlocked' }}"
                      sequence:
                        - wait_for_trigger:
                            - platform: state
                              entity_id: !input lock_entity
                              to: "locked"
                          timeout: { seconds: !input reminder_interval }
                          continue_on_timeout: true
                        - condition: template
                          value_template: "{{ states(lock_ent) == 'unlocked' }}"
                        - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                        - service: media_player.volume_set
                          target: { entity_id: !input media_players }
                          data: { volume_level: "{{ tts_volume_level }}" }
                        - choose:
                            - conditions: [{ condition: template, value_template: "{{ use_voice_option }}" }]
                              sequence:
                                - service: tts.speak
                                  target: { entity_id: !input tts_engine }
                                  data:
                                    message: "{{ final_unlocked_reminder }}"
                                    cache: !input tts_cache
                                    media_player_entity_id: !input media_players
                                    options: { voice: !input tts_voice }
                          default:
                            - service: tts.speak
                              target: { entity_id: !input tts_engine }
                              data:
                                message: "{{ final_unlocked_reminder }}"
                                cache: !input tts_cache
                                media_player_entity_id: !input media_players
            default: []

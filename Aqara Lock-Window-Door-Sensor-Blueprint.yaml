blueprint:
  name: Aqara Door/Window Auto-Lock + Announce (Queued)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    Auto-lock a smart lock X seconds after the contact sensor reports CLOSED (re-checks before locking).
    Optional TTS announcements for sensor open/close and lock locked/unlocked.
    Messages are queued (mode: queued, max: 8) to avoid audio overlap.

    ğŸ”Š Default TTS phrasing uses **Area (room)** + **Door type**:
      â€¢ Bedroom  â†’ â€œ<room> door was <action>â€
      â€¢ Hallway  â†’ â€œ<room> door was <action>â€
      â€¢ Closet   â†’ â€œ<room> closet door was <action>â€
      â€¢ Entrance â†’ â€œ<room> entrance door was <action>â€
      â€¢ Window   â†’ â€œ<room> window was <action>â€

    â€œ<room>â€ comes from the entityâ€™s Area (assign your sensor/lock to the correct Area).
    Custom messages (optional) can use {room} to substitute the Area name.

  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door/window)
      description: |-
        Pick the contact sensor for THIS door or window.
        For most Aqara sensors, ON = open and OFF = closed.
        Device class should be door, opening, or window.
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - door
            - opening
            - window

    lock_entity:
      name: Smart lock
      description: |-
        Pick the lock entity to control (Aqara or any lock.*).
      selector:
        entity:
          domain: lock

    door_type:
      name: Door type (affects default TTS wording)
      description: |-
        Controls how the default TTS refers to the opening:
          â€¢ Bedroom  â†’ â€œ<room> door was <action>â€
          â€¢ Hallway  â†’ â€œ<room> door was <action>â€
          â€¢ Closet   â†’ â€œ<room> closet door was <action>â€
          â€¢ Entrance â†’ â€œ<room> entrance door was <action>â€
          â€¢ Window   â†’ â€œ<room> window was <action>â€
        (Custom messages override these defaults and can use {room}.)
      default: bedroom
      selector:
        select:
          mode: dropdown
          options:
            - bedroom
            - hallway
            - closet
            - entrance
            - window

    lock_delay:
      name: Auto-lock delay (seconds)
      description: |-
        How long after the sensor first reports CLOSED to attempt locking.
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    closed_stability:
      name: Closed stability window (seconds)
      description: |-
        Extra time the sensor must remain closed (no bounce) before locking.
        Set to 0 to skip. After the main delay we wait this long and re-check closed.
      default: 0
      selector:
        number:
          min: 0
          max: 120
          unit_of_measurement: seconds
          mode: slider

    announce_enabled:
      name: Speak announcements
      description: |-
        Turn on to speak every contact/lock state change.
      default: false
      selector:
        boolean: {}

    announce_sensor:
      name: Announce sensor open/close
      description: |-
        If on, we announce sensor opened/closed events (from your window/door sensor).
      default: true
      selector:
        boolean: {}

    announce_lock:
      name: Announce lock state changes
      description: |-
        If on, we announce locked/unlocked (transitional states are ignored).
      default: true
      selector:
        boolean: {}

    tts_engine:
      name: TTS engine
      description: |-
        Pick your TTS engine entity (e.g., tts.piper). Required if announcements are enabled.
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: |-
        One or more media_player entities to speak on (used only if announcements are enabled).
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: |-
        Let Home Assistant cache synthesized speech when supported.
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: |-
        If supported by your TTS provider (options.voice). Leave blank for default.
      default: ""
      selector:
        text: {}

    # Pre-roll to avoid clipped first word; lower this to start faster
    tts_preroll_ms:
      name: TTS pre-roll (milliseconds)
      description: |-
        Short delay before speaking to avoid clipping the start of the message.
        If it feels slow, reduce (typical: 150â€“300 ms).
      default: 250
      selector:
        number:
          min: 0
          max: 1500
          step: 50
          unit_of_measurement: ms
          mode: slider

    # Optional custom messages (use {room}) â€“ leave blank to use standardized defaults
    custom_open_msg:
      name: Custom message â€” sensor OPENED (optional)
      description: |-
        Use {room}. Example: "{room} door was opened."
      default: ""
      selector:
        text: {}

    custom_closed_msg:
      name: Custom message â€” sensor CLOSED (optional)
      description: |-
        Use {room}. Example: "{room} door was closed."
      default: ""
      selector:
        text: {}

    custom_locked_msg:
      name: Custom message â€” LOCKED (optional)
      description: |-
        Use {room}. Example: "{room} door was locked."
      default: ""
      selector:
        text: {}

    custom_unlocked_msg:
      name: Custom message â€” UNLOCKED (optional)
      description: |-
        Use {room}. Example: "{room} door was unlocked."
      default: ""
      selector:
        text: {}

mode: queued
max: 8

trigger:
  - id: sensor_opened
    platform: state
    entity_id: !input door_sensor
    to: "on"

  - id: sensor_closed
    platform: state
    entity_id: !input door_sensor
    to: "off"

  - id: lock_changed
    platform: state
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity

      # Areas â†’ room labels (no friendly names used for TTS)
      sensor_area: "{{ area_name(sensor_ent) }}"
      lock_area: "{{ area_name(lock_ent) }}"
      room_for_sensor: "{{ sensor_area or lock_area or 'Door' }}"
      room_for_lock:   "{{ lock_area or sensor_area or 'Door' }}"

      # Door type (controls nouning for defaults)
      door_type_in: !input door_type

      # Build the spoken subject for sensor/lock messages based on door_type
      subject_sensor: >-
        {% set r = room_for_sensor %}
        {% set t = (door_type_in or 'bedroom') %}
        {% if t == 'window' %}
          {{ r }} window
        {% elif t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}
      subject_lock: >-
        {% set r = room_for_lock %}
        {% set t = (door_type_in or 'bedroom') %}
        {% if t == 'window' %}
          {{ r }} window
        {% elif t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}

      # Inputs (bound so templates can read them)
      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      stability: !input closed_stability
      tts_preroll_ms: !input tts_preroll_ms

      # Custom message inputs
      custom_open_msg_in: !input custom_open_msg
      custom_closed_msg_in: !input custom_closed_msg
      custom_locked_msg_in: !input custom_locked_msg
      custom_unlocked_msg_in: !input custom_unlocked_msg

      # Can/should we speak?
      has_tts: >-
        {{ announce_enabled and (players | length > 0)
           and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
      do_tts_sensor: "{{ has_tts and announce_sensor }}"
      do_tts_lock: "{{ has_tts and announce_lock }}"
      has_voice: "{{ (tts_voice_name | default('') | trim) != '' }}"

      # Final message strings (standardized, type-aware)
      final_opened: |-
        {% set base = (custom_open_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_sensor) }}
        {% else %}{{ subject_sensor ~ ' was opened.' }}{% endif %}
      final_closed: |-
        {% set base = (custom_closed_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_sensor) }}
        {% else %}{{ subject_sensor ~ ' was closed.' }}{% endif %}
      final_locked: |-
        {% set base = (custom_locked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_lock) }}
        {% else %}{{ subject_lock ~ ' was locked.' }}{% endif %}
      final_unlocked: |-
        {% set base = (custom_unlocked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_lock) }}
        {% else %}{{ subject_lock ~ ' was unlocked.' }}{% endif %}

  - choose:

      # ---------- SENSOR OPENED ----------
      - conditions:
          - condition: trigger
            id: sensor_opened
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay:
                      milliseconds: "{{ tts_preroll_ms | int }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_opened }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_opened }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

      # ---------- SENSOR CLOSED (speak first, then fully guarded auto-lock) ----------
      - conditions:
          - condition: trigger
            id: sensor_closed
        sequence:
          # Speak CLOSED immediately (with pre-roll)
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay:
                      milliseconds: "{{ tts_preroll_ms | int }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_closed }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_closed }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Guard 1: wait lock_delay unless sensor OPENS -> cancel
          - wait_for_trigger:
              - platform: state
                entity_id: !input door_sensor
                to: "on"
            timeout:
              seconds: !input lock_delay
            continue_on_timeout: true
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait.completed | default(false) }}"
                sequence:
                  - stop: "Door reopened during delay; cancel auto-lock."
            default: []

          # Confirm still closed
          - condition: state
            entity_id: !input door_sensor
            state: "off"

          # Guard 2: optional stability window; cancel if opens
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (stability | int) > 0 }}"
                sequence:
                  - wait_for_trigger:
                      - platform: state
                        entity_id: !input door_sensor
                        to: "on"
                    timeout:
                      seconds: !input closed_stability
                    continue_on_timeout: true
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ wait.completed | default(false) }}"
                        sequence:
                          - stop: "Door reopened during stability; cancel auto-lock."
                    default: []
            default: []

          # Final re-check + last-moment guard
          - condition: state
            entity_id: !input door_sensor
            state: "off"
          - wait_for_trigger:
              - platform: state
                entity_id: !input door_sensor
                to: "on"
            timeout:
              seconds: 1
            continue_on_timeout: true
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait.completed | default(false) }}"
                sequence:
                  - stop: "Door reopened at final guard; cancel auto-lock."
            default: []

          # Only lock if not already locked
          - condition: template
            value_template: "{{ not is_state(lock_ent, 'locked') }}"
          - service: lock.lock
            target: { entity_id: !input lock_entity }

      # ---------- LOCK CHANGED (only locked/unlocked, with confirmation) ----------
      - conditions:
          - condition: trigger
            id: lock_changed
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_lock and trigger.to_state.state in ['locked','unlocked'] }}"
                sequence:
                  # Confirm the state really stuck before speaking (avoid false positives)
                  - delay:
                      milliseconds: 150
                  - condition: template
                    value_template: "{{ is_state(lock_ent, trigger.to_state.state) }}"
                  - delay:
                      milliseconds: "{{ tts_preroll_ms | int }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: >-
                                {% if trigger.to_state.state == 'locked' %}
                                  {{ final_locked }}
                                {% else %}
                                  {{ final_unlocked }}
                                {% endif %}
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% if trigger.to_state.state == 'locked' %}
                              {{ final_locked }}
                            {% else %}
                              {{ final_unlocked }}
                            {% endif %}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

blueprint:
  name: Aqara Door/Window Auto-Lock + Announce (Queued, Sensor-only or Lock-only)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    Use this ONE blueprint for:
      • Sensor-only announcements (OPENED/CLOSED)
      • Lock-only announcements (LOCKED/UNLOCKED)
      • Both together with guarded auto-lock

    How it works
      • If a contact sensor is provided and reports CLOSED, we speak immediately,
        then wait X seconds; auto-lock runs only if it never re-opens (two guards + final re-check).
      • Lock announcements trigger only for LOCKED/UNLOCKED (transitional states are ignored).
      • Messages queue (no overlap) because the automation runs in `mode: queued`.

  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door/window) — optional
      description: |-
        Leave blank if you don't want sensor features.
        For most Aqara sensors, ON = open and OFF = closed.
        Device class should be door, opening, or window.
      default: ""
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - door
            - opening
            - window

    lock_entity:
      name: Smart lock — optional
      description: |-
        Leave blank if you don't want lock features.
        Works with Aqara or any `lock.*`.
      default: ""
      selector:
        entity:
          domain: lock

    lock_delay:
      name: Auto-lock delay (seconds)
      description: |-
        How long after the sensor first reports CLOSED to attempt locking.
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    closed_stability:
      name: Closed stability window (seconds)
      description: |-
        Extra time the sensor must remain CLOSED (no bounce) before locking.
        Set to 0 to skip. After the main delay we wait this long and re-check closed.
      default: 0
      selector:
        number:
          min: 0
          max: 120
          unit_of_measurement: seconds
          mode: slider

    announce_enabled:
      name: Speak announcements
      description: |-
        Turn on to speak contact/lock state changes (requires TTS engine + speakers).
      default: false
      selector:
        boolean: {}

    announce_sensor:
      name: Announce sensor open/close
      description: |-
        If on, we announce sensor opened/closed events (from your window/door sensor).
      default: true
      selector:
        boolean: {}

    announce_lock:
      name: Announce lock state changes
      description: |-
        If on, we announce LOCKED/UNLOCKED only (transitional states are ignored).
      default: true
      selector:
        boolean: {}

    tts_engine:
      name: TTS engine
      description: |-
        Pick your TTS engine entity (e.g., `tts.piper`). Required if announcements are enabled.
      default: ""
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: |-
        One or more `media_player.*` entities to speak on (used only if announcements are enabled).
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: |-
        Let Home Assistant cache synthesized speech when supported.
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: |-
        If supported by your TTS provider (`options.voice`). Leave blank for default.
      default: ""
      selector:
        text: {}

    custom_open_msg:
      name: Custom message — sensor OPENED (optional)
      description: |-
        Use {door} or {sensor}, e.g. "{door} opened." Leave blank for default.
      default: ""
      selector:
        text: {}

    custom_closed_msg:
      name: Custom message — sensor CLOSED (optional)
      description: |-
        Use {door} or {sensor}, e.g. "{door} closed." Leave blank for default.
      default: ""
      selector:
        text: {}

    custom_locked_msg:
      name: Custom message — LOCKED (optional)
      description: |-
        Use {lock}, e.g. "{lock} locked." Leave blank for default.
      default: ""
      selector:
        text: {}

    custom_unlocked_msg:
      name: Custom message — UNLOCKED (optional)
      description: |-
        Use {lock}, e.g. "{lock} unlocked." Leave blank for default.
      default: ""
      selector:
        text: {}

mode: queued
max: 50

# One lightweight global trigger; we filter events inside actions.
trigger:
  - platform: event
    event_type: state_changed

condition: []

action:
  - variables:
      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity

      # Are inputs set?
      sensor_set: "{{ sensor_ent is string and (sensor_ent|length) > 0 }}"
      lock_set: "{{ lock_ent is string and (lock_ent|length) > 0 }}"

      # Friendly names (resolve lazily at runtime)
      sensor_name: "{{ state_attr(sensor_ent, 'friendly_name') or sensor_ent }}"
      lock_name: "{{ state_attr(lock_ent, 'friendly_name') or lock_ent }}"

      # TTS plumbing
      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      has_voice: "{{ (tts_voice_name | default('') | trim) != '' }}"
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      has_tts: >-
        {{ announce_enabled and (players | length > 0)
           and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
      do_tts_sensor: "{{ has_tts and announce_sensor and sensor_set }}"
      do_tts_lock: "{{ has_tts and announce_lock and lock_set }}"

      # Timing
      stability: !input closed_stability

      # Bind custom messages
      custom_open_msg_in: !input custom_open_msg
      custom_closed_msg_in: !input custom_closed_msg
      custom_locked_msg_in: !input custom_locked_msg
      custom_unlocked_msg_in: !input custom_unlocked_msg

      # Final message strings
      final_opened: >-
        {% set base = (custom_open_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{door}', sensor_name).replace('{sensor}', sensor_name) }}
        {% else %}{{ sensor_name ~ ' opened.' }}{% endif %}
      final_closed: >-
        {% set base = (custom_closed_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{door}', sensor_name).replace('{sensor}', sensor_name) }}
        {% else %}{{ sensor_name ~ ' closed.' }}{% endif %}
      final_locked: >-
        {% set base = (custom_locked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{lock}', lock_name) }}
        {% else %}{{ lock_name ~ ' locked.' }}{% endif %}
      final_unlocked: >-
        {% set base = (custom_unlocked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{lock}', lock_name) }}
        {% else %}{{ lock_name ~ ' unlocked.' }}{% endif %}

  - choose:

      # ===== SENSOR EVENTS (OPEN/CLOSE) =====
      - conditions:
          - condition: template
            value_template: >-
              {{ sensor_set
                 and trigger.event.data is mapping
                 and trigger.event.data.entity_id == sensor_ent }}
        sequence:

          # Speak OPENED immediately
          - choose:
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ do_tts_sensor
                         and trigger.event.data.new_state is mapping
                         and trigger.event.data.new_state.state == 'on' }}
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_opened }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_opened }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Speak CLOSED immediately, then guarded auto-lock flow
          - choose:
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ trigger.event.data.new_state is mapping
                         and trigger.event.data.new_state.state == 'off' }}
                sequence:
                  # TTS for CLOSED (if enabled)
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ do_tts_sensor }}"
                        sequence:
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ has_voice }}"
                                sequence:
                                  - service: tts.speak
                                    target: { entity_id: !input tts_engine }
                                    data:
                                      message: "{{ final_closed }}"
                                      cache: !input tts_cache
                                      media_player_entity_id: !input media_players
                                      options: { voice: !input tts_voice }
                            default:
                              - service: tts.speak
                                target: { entity_id: !input tts_engine }
                                data:
                                  message: "{{ final_closed }}"
                                  cache: !input tts_cache
                                  media_player_entity_id: !input media_players
                    default: []

                  # Only attempt auto-lock if a lock is configured
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ lock_set }}"
                        sequence:

                          # Guard 1: wait `lock_delay` unless sensor OPENS → cancel
                          - wait_for_trigger:
                              - platform: state
                                entity_id: !input door_sensor
                                to: "on"
                            timeout:
                              seconds: !input lock_delay
                            continue_on_timeout: true
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ wait.completed | default(false) }}"
                                sequence:
                                  - stop: "Door reopened during delay; cancel auto-lock."
                            default: []

                          # Confirm still CLOSED
                          - condition: state
                            entity_id: !input door_sensor
                            state: "off"

                          # Guard 2: optional stability window; cancel if opens
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ (stability | int) > 0 }}"
                                sequence:
                                  - wait_for_trigger:
                                      - platform: state
                                        entity_id: !input door_sensor
                                        to: "on"
                                    timeout:
                                      seconds: !input closed_stability
                                    continue_on_timeout: true
                                  - choose:
                                      - conditions:
                                          - condition: template
                                            value_template: "{{ wait.completed | default(false) }}"
                                        sequence:
                                          - stop: "Door reopened during stability; cancel auto-lock."
                                    default: []
                            default: []

                          # Final re-check + last-moment guard
                          - condition: state
                            entity_id: !input door_sensor
                            state: "off"
                          - wait_for_trigger:
                              - platform: state
                                entity_id: !input door_sensor
                                to: "on"
                            timeout:
                              seconds: 1
                            continue_on_timeout: true
                          - choose:
                              - conditions:
                                  - condition: template
                                    value_template: "{{ wait.completed | default(false) }}"
                                sequence:
                                  - stop: "Door reopened at final guard; cancel auto-lock."
                            default: []

                          # Only lock if not already locked
                          - condition: template
                            value_template: "{{ not is_state(lock_ent, 'locked') }}"
                          - service: lock.lock
                            target: { entity_id: !input lock_entity }
                    default: []

      # ===== LOCK EVENTS (LOCKED/UNLOCKED only) =====
      - conditions:
          - condition: template
            value_template: >-
              {{ lock_set
                 and trigger.event.data is mapping
                 and trigger.event.data.entity_id == lock_ent
                 and trigger.event.data.new_state is mapping
                 and trigger.event.data.new_state.state in ['locked','unlocked'] }}
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_lock }}"
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: >-
                                {% if trigger.event.data.new_state.state == 'locked' %}
                                  {{ final_locked }}
                                {% else %}
                                  {{ final_unlocked }}
                                {% endif %}
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% if trigger.event.data.new_state.state == 'locked' %}
                              {{ final_locked }}
                            {% else %}
                              {{ final_unlocked }}
                            {% endif %}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []


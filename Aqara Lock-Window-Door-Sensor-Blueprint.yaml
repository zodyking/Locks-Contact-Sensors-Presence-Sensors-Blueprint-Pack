blueprint:
  name: Aqara Door/Window Auto-Lock + Announce (Queued)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    Auto-lock a smart lock X seconds after the contact sensor reports **CLOSED** (re-checks before locking).
    Optional TTS announcements for **all** state changes of the contact sensor (door/window) and the lock.
    Messages queue (no overlap) because this automation runs in `mode: queued`.
  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door/window)
      description: >
        Pick the contact sensor for THIS door or window.
        For most Aqara sensors, **ON = open** and **OFF = closed**.
        Device class should be `door`, `opening`, or `window`.
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - door
            - opening
            - window

    lock_entity:
      name: Smart lock
      description: "Pick the lock entity to control (Aqara or any `lock.*`)."
      selector:
        entity:
          domain: lock

    lock_delay:
      name: Auto-lock delay (seconds)
      description: "How long after the sensor first reports CLOSED to attempt locking."
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    closed_stability:
      name: Closed stability window (seconds)
      description: >
        Extra time the sensor must remain closed (no bounce) before locking.
        Set to 0 to skip. After the main delay we wait this long and re-check closed.
      default: 0
      selector:
        number:
          min: 0
          max: 120
          unit_of_measurement: seconds
          mode: slider

    announce_enabled:
      name: Speak announcements
      description: "Turn on to speak every contact/lock state change."
      default: false
      selector:
        boolean: {}

    announce_sensor:
      name: Announce sensor open/close
      description: "If on, we announce sensor opened/closed events (from your window/door sensor)."
      default: true
      selector:
        boolean: {}

    announce_lock:
      name: Announce lock state changes
      description: "If on, we announce locked/unlocked/locking/unlocking/jammed."
      default: true
      selector:
        boolean: {}

    tts_engine:
      name: TTS engine
      description: "Pick your TTS engine entity (e.g., `tts.piper`). Required if announcements are enabled."
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: "One or more media_player entities to speak on (used only if announcements are enabled)."
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: "Let Home Assistant cache synthesized speech when supported."
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: "If supported by your TTS provider (options.voice). Leave blank for default."
      default: ""
      selector:
        text: {}

    custom_open_msg:
      name: Custom message — sensor OPENED (optional)
      description: 'Use {door} placeholder, e.g. "{door} opened." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_closed_msg:
      name: Custom message — sensor CLOSED (optional)
      description: 'Use {door} placeholder, e.g. "{door} closed." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_locked_msg:
      name: Custom message — LOCKED (optional)
      description: 'Use {lock} placeholder, e.g. "{lock} locked." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_unlocked_msg:
      name: Custom message — UNLOCKED (optional)
      description: 'Use {lock} placeholder, e.g. "{lock} unlocked." Leave blank for default.'
      default: ""
      selector:
        text: {}

mode: queued
max: 50

trigger:
  - id: sensor_opened
    platform: "state"
    entity_id: !input door_sensor
    to: "on"

  - id: sensor_closed
    platform: "state"
    entity_id: !input door_sensor
    to: "off"

  - id: lock_changed
    platform: "state"
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity
      sensor_name: "{{ state_attr(sensor_ent, 'friendly_name') or sensor_ent }}"
      lock_name: "{{ state_attr(lock_ent, 'friendly_name') or lock_ent }}"
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      custom_open_msg: !input custom_open_msg
      custom_closed_msg: !input custom_closed_msg
      custom_locked_msg: !input custom_locked_msg
      custom_unlocked_msg: !input custom_unlocked_msg
      stability: !input closed_stability

  - choose:

      # ---------- SENSOR OPENED: speak immediately ----------
      - conditions:
          - condition: trigger
            id: sensor_opened
          - condition: template
            value_template: >
              {{ announce_enabled and announce_sensor and (players | length > 0)
                 and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
        sequence:
          - choose:
              - conditions: "{{ (tts_voice_name | default('') | trim) != '' }}"
                sequence:
                  - service: tts.speak
                    target: { entity_id: !input tts_engine }
                    data:
                      message: >-
                        {% set base = (custom_open_msg | default('') | trim) %}
                        {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' opened.' }}
                      cache: !input tts_cache
                      media_player_entity_id: !input media_players
                      options: { voice: !input tts_voice }
              - conditions: []
                sequence:
                  - service: tts.speak
                    target: { entity_id: !input tts_engine }
                    data:
                      message: >-
                        {% set base = (custom_open_msg | default('') | trim) %}
                        {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' opened.' }}
                      cache: !input tts_cache
                      media_player_entity_id: !input media_players

      # ---------- SENSOR CLOSED: speak immediately, THEN guarded auto-lock ----------
      - conditions:
          - condition: trigger
            id: sensor_closed
        sequence:
          # Speak CLOSED right away
          - if:
              - condition: template
                value_template: >
                  {{ announce_enabled and announce_sensor and (players | length > 0)
                     and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
            then:
              - choose:
                  - conditions: "{{ (tts_voice_name | default('') | trim) != '' }}"
                    sequence:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% set base = (custom_closed_msg | default('') | trim) %}
                            {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' closed.' }}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
                          options: { voice: !input tts_voice }
                  - conditions: []
                    sequence:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% set base = (custom_closed_msg | default('') | trim) %}
                            {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' closed.' }}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players

          # Guard 1: wait lock_delay unless the sensor OPENS, then cancel
          - wait_for_trigger:
              - platform: "state"
                entity_id: !input door_sensor
                to: "on"
            timeout:
              seconds: !input lock_delay
            continue_on_timeout: true
          - if:
              - condition: template
                value_template: "{{ wait.completed | default(false) }}"
            then:
              - stop: "Door reopened during delay; cancel auto-lock."

          # Confirm still closed
          - condition: state
            entity_id: !input door_sensor
            state: "off"

          # Guard 2: optional stability window; cancel if opens
          - choose:
              - conditions: "{{ (stability | int) > 0 }}"
                sequence:
                  - wait_for_trigger:
                      - platform: "state"
                        entity_id: !input door_sensor
                        to: "on"
                    timeout:
                      seconds: "{{ stability | int }}"
                    continue_on_timeout: true
                  - if:
                      - condition: template
                        value_template: "{{ wait.completed | default(false) }}"

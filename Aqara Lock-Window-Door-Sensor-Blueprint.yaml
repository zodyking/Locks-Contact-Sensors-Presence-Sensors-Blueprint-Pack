blueprint:
  name: Aqara Door Auto-Lock + Announce (Queued)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    Automates a smart lock using a door contact sensor with optional spoken announcements.
    Built for reliability and clear speech.

    What it does
    • Auto-locks the door X seconds after the sensor reports CLOSED (with multiple re-check guards).
    • Cancels the lock if the sensor re-opens at any point before the command.
    • Optional “closed stability” window to filter sensor bounce.
    • Speaks OPENED/CLOSED and LOCKED/UNLOCKED (only after real, confirmed state changes).
    • Optional reminders: repeats a message every X seconds while the door is OPEN
      and/or the lock is UNLOCKED, until it’s resolved (stops immediately when fixed).
    • Optional action: turn on selected lights/switches when the door opens.
    • All speech is queued (mode: queued, max: 2) and a small TTS pre-roll prevents clipped words.

    Setup
    1) Select the contact sensor and the lock.
    2) (Optional) Enable announcements, choose a TTS engine (e.g., tts.piper), and select one or more media_player targets.
    3) Tune Auto-lock delay and Closed stability to match your door behavior.
    4) (Optional) Provide custom messages; you can use {room} to insert the device’s Area name.
    5) (Optional) Enable reminders and set the interval, and/or select entities to turn on when the door opens.

    Notes
    • The spoken “room” name comes from the entity’s Area (Settings → Areas). Assign your devices to Areas for natural phrases.
    • Lock announcements trigger only when the lock actually reports locked/unlocked (with a brief confirmation).
    • Works with Aqara and other standard Home Assistant binary_sensor/lock entities.

  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door)
      description: |-
        Pick the contact sensor for THIS door.
        For most Aqara sensors, ON = open and OFF = closed.
        Device class should be door or opening.
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - door
            - opening

    lock_entity:
      name: Smart lock
      description: |-
        Pick the lock entity to control (Aqara or any lock.*).
      selector:
        entity:
          domain: lock

    door_type:
      name: Door type (affects default TTS wording)
      description: |-
        Controls how the default TTS refers to the opening (used together with the Area name):
          • Bedroom  → “<room> door was <action>”
          • Hallway  → “<room> door was <action>”
          • Closet   → “<room> closet door was <action>”
          • Entrance → “<room> entrance door was <action>”
        (Custom messages override these defaults and can use {room}.)
      default: bedroom
      selector:
        select:
          mode: dropdown
          options:
            - bedroom
            - hallway
            - closet
            - entrance

    lock_delay:
      name: Auto-lock delay (seconds)
      description: |-
        How long after the sensor first reports CLOSED to attempt locking.
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    closed_stability:
      name: Closed stability window (seconds)
      description: |-
        Extra time the sensor must remain closed (no bounce) before locking.
        Set to 0 to skip. After the main delay we wait this long and re-check closed.
      default: 2
      selector:
        number:
          min: 0
          max: 10
          unit_of_measurement: seconds
          mode: slider

    announce_enabled:
      name: Speak announcements
      description: |-
        Turn on to speak every contact/lock state change.
      default: false
      selector:
        boolean: {}

    announce_sensor:
      name: Announce sensor open/close
      description: |-
        If on, we announce sensor opened/closed events (from your door sensor).
      default: true
      selector:
        boolean: {}

    announce_lock:
      name: Announce lock state changes
      description: |-
        If on, we announce locked/unlocked (transitional states are ignored).
      default: true
      selector:
        boolean: {}

    # Reminders
    open_reminder_enabled:
      name: Repeat reminder while OPEN
      description: |-
        If on, we repeat a reminder message while the door is open until it’s closed.
      default: false
      selector:
        boolean: {}

    unlocked_reminder_enabled:
      name: Repeat reminder while UNLOCKED
      description: |-
        If on, we repeat a reminder message while the lock is unlocked until it’s locked.
      default: false
      selector:
        boolean: {}

    reminder_interval:
      name: Reminder interval (seconds)
      description: |-
        How often to repeat reminder messages while the condition stays true.
      default: 30
      selector:
        number:
          min: 15
          max: 120
          unit_of_measurement: seconds
          mode: slider

    # Turn on entities on open
    open_turn_on_entities:
      name: Turn on when door opens (optional)
      description: |-
        Select lights/switches to turn on immediately when the door opens. Leave empty to disable.
      default: []
      selector:
        entity:
          multiple: true
          domain:
            - light
            - switch

    # TTS plumbing
    tts_engine:
      name: TTS engine
      description: |-
        Pick your TTS engine entity (e.g., tts.piper). Required if announcements are enabled.
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: |-
        One or more media_player entities to speak on (used only if announcements are enabled).
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: |-
        Let Home Assistant cache synthesized speech when supported.
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: |-
        If supported by your TTS provider (options.voice). Leave blank for default.
      default: ""
      selector:
        text: {}

    # Pre-roll to avoid clipped first word; lower this to start faster
    tts_preroll_ms:
      name: TTS pre-roll (milliseconds)
      description: |-
        Short delay before speaking to avoid clipping the start of the message.
        If it feels slow, reduce (typical: 150–200 ms).
      default: 150
      selector:
        number:
          min: 0
          max: 300
          step: 10
          unit_of_measurement: ms
          mode: slider

    # Optional custom messages (use {room}) – leave blank to use standardized defaults
    custom_open_msg:
      name: Custom message — sensor OPENED (optional)
      description: |-
        Use {room}. Example: "{room} door was opened."
      default: ""
      selector:
        text: {}

    custom_closed_msg:
      name: Custom message — sensor CLOSED (optional)
      description: |-
        Use {room}. Example: "{room} door was closed."
      default: ""
      selector:
        text: {}

    custom_locked_msg:
      name: Custom message — LOCKED (optional)
      description: |-
        Use {room}. Example: "{room} door was locked."
      default: ""
      selector:
        text: {}

    custom_unlocked_msg:
      name: Custom message — UNLOCKED (optional)
      description: |-
        Use {room}. Example: "{room} door was unlocked."
      default: ""
      selector:
        text: {}

mode: queued
max: 2

trigger:
  # Immediate events for TTS and other reactions
  - id: sensor_opened
    platform: state
    entity_id: !input door_sensor
    to: "on"

  - id: sensor_closed
    platform: state
    entity_id: !input door_sensor
    to: "off"

  # Resilient auto-lock trigger: fires only if the door has been CLOSED
  # continuously for the full lock_delay window
  - id: sensor_closed_lock_delay_done
    platform: state
    entity_id: !input door_sensor
    to: "off"
    for:
      seconds: !input lock_delay

  - id: lock_changed
    platform: state
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity

      # Areas → room labels (no friendly names used for TTS)
      sensor_area: "{{ area_name(sensor_ent) }}"
      lock_area: "{{ area_name(lock_ent) }}"
      room_for_sensor: "{{ sensor_area or lock_area or 'Door' }}"
      room_for_lock:   "{{ lock_area or sensor_area or 'Door' }}"

      # Door type (controls nouning for defaults)
      door_type_in: !input door_type

      # Build the spoken subject for sensor/lock messages based on door_type
      subject_sensor: >-
        {% set r = room_for_sensor %}
        {% set t = (door_type_in or 'bedroom') %}
        {% if t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}
      subject_lock: >-
        {% set r = room_for_lock %}
        {% set t = (door_type_in or 'bedroom') %}
        {% if t in ['closet','entrance'] %}
          {{ r }} {{ t }} door
        {% else %}
          {{ r }} door
        {% endif %}

      # Inputs (bound so templates can read them)
      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      stability: !input closed_stability
      tts_preroll_ms: !input tts_preroll_ms

      # Reminders
      open_reminder_enabled: !input open_reminder_enabled
      unlocked_reminder_enabled: !input unlocked_reminder_enabled
      reminder_interval: !input reminder_interval
      open_turn_on_entities: !input open_turn_on_entities

      # Custom messages (non-reminder)
      custom_open_msg_in: !input custom_open_msg
      custom_closed_msg_in: !input custom_closed_msg
      custom_locked_msg_in: !input custom_locked_msg
      custom_unlocked_msg_in: !input custom_unlocked_msg

      # Speak?
      has_tts: >-
        {{ announce_enabled and (players | length > 0)
           and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
      do_tts_sensor: "{{ has_tts and announce_sensor }}"
      do_tts_lock: "{{ has_tts and announce_lock }}"
      do_tts_open_reminder: "{{ has_tts and open_reminder_enabled }}"
      do_tts_unlocked_reminder: "{{ has_tts and unlocked_reminder_enabled }}"
      has_voice: "{{ (tts_voice_name | default('') | trim) != '' }}"

      # Final message strings
      final_opened: |-
        {% set base = (custom_open_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_sensor) }}
        {% else %}{{ subject_sensor ~ ' was opened.' }}{% endif %}
      final_closed: |-
        {% set base = (custom_closed_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_sensor) }}
        {% else %}{{ subject_sensor ~ ' was closed.' }}{% endif %}
      final_locked: |-
        {% set base = (custom_locked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_lock) }}
        {% else %}{{ subject_lock ~ ' was locked.' }}{% endif %}
      final_unlocked: |-
        {% set base = (custom_unlocked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{room}', room_for_lock) }}
        {% else %}{{ subject_lock ~ ' was unlocked.' }}{% endif %}

      # Auto-generated reminder messages
      final_open_reminder: "{{ subject_sensor ~ ' is still open.' }}"
      final_unlocked_reminder: "{{ subject_lock ~ ' is still unlocked.' }}"

  - choose:

      # ---------- SENSOR OPENED ----------
      - conditions:
          - condition: trigger
            id: sensor_opened
        sequence:
          # Optional: turn on entities on open
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (open_turn_on_entities | length) > 0 }}"
                sequence:
                  - service: homeassistant.turn_on
                    target:
                      entity_id: !input open_turn_on_entities
            default: []

          # Speak OPENED
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ has_voice }}" }]
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_opened }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_opened }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Repeat reminder while OPEN (interruptible immediately on close)
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_open_reminder }}"
                sequence:
                  - repeat:
                      while:
                        - condition: template
                          value_template: "{{ states(sensor_ent) == 'on' }}"
                      sequence:
                        # Wait for close OR timeout → speak if still open
                        - wait_for_trigger:
                            - platform: state
                              entity_id: !input door_sensor
                              to: "off"
                          timeout: { seconds: !input reminder_interval }
                          continue_on_timeout: true
                        - condition: template
                          value_template: "{{ states(sensor_ent) == 'on' }}"
                        - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                        - choose:
                            - conditions: [{ condition: template, value_template: "{{ has_voice }}" }]
                              sequence:
                                - service: tts.speak
                                  target: { entity_id: !input tts_engine }
                                  data:
                                    message: "{{ final_open_reminder }}"
                                    cache: !input tts_cache
                                    media_player_entity_id: !input media_players
                                    options: { voice: !input tts_voice }
                          default:
                            - service: tts.speak
                              target: { entity_id: !input tts_engine }
                              data:
                                message: "{{ final_open_reminder }}"
                                cache: !input tts_cache
                                media_player_entity_id: !input media_players
            default: []

      # ---------- SENSOR CLOSED (immediate TTS only) ----------
      - conditions:
          - condition: trigger
            id: sensor_closed
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - delay: { milliseconds: "{{ tts_preroll_ms | int }}" }
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ has_voice }}" }]
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_closed }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_closed }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

      # ---------- AUTO-LOCK after door stayed CLOSED for lock_delay ----------
      - conditions:
          - condition: trigger
            id: sensor_closed_lock_delay_done
        sequence:
          # If stability > 0, give a last stability window; cancel if re-opens
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (stability | int) > 0 }}"
                sequence:
                  - wait_for_trigger:
                      - platform: state
                        entity_id: !input door_sensor
                        to: "on"
                    timeout: { seconds: !input closed_stability }
                    continue_on_timeout: true
                  - choose:
                      - conditions: [{ condition: template, value_template: "{{ wait.completed | default(false) }}" }]
                        sequence:
                          - stop: "Door reopened during stability; cancel auto-lock."
                    default: []
            default: []

          # Final re-check + last-moment guard
          - condition: template
            value_template: "{{ states(sensor_ent) == 'off' }}"
          - wait_for_trigger:
              - platform: state

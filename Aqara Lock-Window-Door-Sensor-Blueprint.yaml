blueprint:
  name: Aqara Door/Window Auto-Lock + Announce (Queued; sensor-only or lock-only via toggles)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    One blueprint for:
      • Sensor-only announcements (OPENED/CLOSED)
      • Lock-only announcements (LOCKED/UNLOCKED)
      • Both together with guarded auto-lock

    How to use:
      • Provide both entities (required so HA never sees a blank entity_id).
      • Use the feature toggles to run sensor-only, lock-only, or both.
      • TTS speaks only LOCKED/UNLOCKED (no transitional states).
      • CLOSED announcement is immediate; auto-lock runs only if the sensor never re-opens
        (delay guard + optional stability guard + final last-moment guard).
      • Messages queue with mode: queued.

  domain: automation

  input:
    enable_sensor_logic:
      name: Enable sensor logic (open/close + auto-lock)
      description: Turn off to disable all contact-sensor behavior.
      default: true
      selector: { boolean: {} }

    enable_lock_logic:
      name: Enable lock logic (locked/unlocked announcements)
      description: Turn off to disable all lock announcements.
      default: true
      selector: { boolean: {} }

    door_sensor:
      name: Contact sensor (door/window)
      description: ON = open, OFF = closed. Device class: door/opening/window.
      selector:
        entity:
          domain: binary_sensor
          device_class: [door, opening, window]

    lock_entity:
      name: Smart lock
      description: Aqara or any lock.*
      selector:
        entity:
          domain: lock

    lock_delay:
      name: Auto-lock delay (seconds)
      description: How long after CLOSED before attempting to lock.
      default: 10
      selector:
        number: { min: 0, max: 60, unit_of_measurement: seconds, mode: slider }

    closed_stability:
      name: Closed stability window (seconds)
      description: Extra time the sensor must remain CLOSED (bounce filter) before locking. 0 = skip.
      default: 0
      selector:
        number: { min: 0, max: 120, unit_of_measurement: seconds, mode: slider }

    announce_enabled:
      name: Speak announcements
      description: Requires a TTS engine and at least one speaker.
      default: false
      selector: { boolean: {} }

    announce_sensor:
      name: Announce sensor open/close
      description: If on, we announce sensor opened/closed events.
      default: true
      selector: { boolean: {} }

    announce_lock:
      name: Announce lock state changes
      description: If on, we announce LOCKED/UNLOCKED only (transitional states ignored).
      default: true
      selector: { boolean: {} }

    tts_engine:
      name: TTS engine
      description: Pick your tts.* entity (e.g., tts.piper). Required if announcements are enabled.
      selector:
        entity:
          domain: tts

    media_players:
      name: Speakers for TTS
      description: One or more media_player.* to speak on.
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      default: false
      selector: { boolean: {} }

    tts_voice:
      name: Voice name (optional)
      description: Engine-specific voice (e.g., Piper `en_US-carlin-high`). Blank = default.
      default: ""
      selector: { text: {} }

    custom_open_msg:
      name: Custom message — sensor OPENED (optional)
      description: Use {door} or {sensor}. Example: "{door} opened."
      default: ""
      selector: { text: {} }

    custom_closed_msg:
      name: Custom message — sensor CLOSED (optional)
      description: Use {door} or {sensor}. Example: "{door} closed."
      default: ""
      selector: { text: {} }

    custom_locked_msg:
      name: Custom message — LOCKED (optional)
      description: Use {lock}. Example: "{lock} locked."
      default: ""
      selector: { text: {} }

    custom_unlocked_msg:
      name: Custom message — UNLOCKED (optional)
      description: Use {lock}. Example: "{lock} unlocked."
      default: ""
      selector: { text: {} }

mode: queued
max: 50

trigger:
  # Sensor triggers (only used if enable_sensor_logic = true)
  - id: sensor_opened
    platform: state
    entity_id: !input door_sensor
    to: "on"
  - id: sensor_closed
    platform: state
    entity_id: !input door_sensor
    to: "off"

  # Lock trigger (only used if enable_lock_logic = true)
  - id: lock_changed
    platform: state
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      use_sensor: !input enable_sensor_logic
      use_lock: !input enable_lock_logic

      sensor_ent: !input door_sensor
      lock_ent: !input lock_entity

      sensor_name: "{{ state_attr(sensor_ent, 'friendly_name') or sensor_ent }}"
      lock_name: "{{ state_attr(lock_ent, 'friendly_name') or lock_ent }}"

      players: !input media_players
      tts_engine_ent: !input tts_engine
      tts_voice_name: !input tts_voice
      tts_cache_val: !input tts_cache
      has_voice: "{{ (tts_voice_name | default('') | trim) != '' }}"
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      has_tts: >-
        {{ announce_enabled and (players | length > 0)
           and (tts_engine_ent is string and tts_engine_ent|length > 0) }}
      do_tts_sensor: "{{ use_sensor and has_tts and announce_sensor }}"
      do_tts_lock: "{{ use_lock and has_tts and announce_lock }}"

      stability: !input closed_stability

      custom_open_msg_in: !input custom_open_msg
      custom_closed_msg_in: !input custom_closed_msg
      custom_locked_msg_in: !input custom_locked_msg
      custom_unlocked_msg_in: !input custom_unlocked_msg

      final_opened: >-
        {% set base = (custom_open_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{door}', sensor_name).replace('{sensor}', sensor_name) }}
        {% else %}{{ sensor_name ~ ' opened.' }}{% endif %}
      final_closed: >-
        {% set base = (custom_closed_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{door}', sensor_name).replace('{sensor}', sensor_name) }}
        {% else %}{{ sensor_name ~ ' closed.' }}{% endif %}
      final_locked: >-
        {% set base = (custom_locked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{lock}', lock_name) }}
        {% else %}{{ lock_name ~ ' locked.' }}{% endif %}
      final_unlocked: >-
        {% set base = (custom_unlocked_msg_in | default('', true) | trim) %}
        {% if base %}{{ base.replace('{lock}', lock_name) }}
        {% else %}{{ lock_name ~ ' unlocked.' }}{% endif %}

  - choose:

      # ---------- SENSOR OPENED ----------
      - conditions:
          - condition: and
            conditions:
              - condition: trigger
                id: sensor_opened
              - condition: template
                value_template: "{{ use_sensor }}"
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_opened }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_opened }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

      # ---------- SENSOR CLOSED (speak first, then guarded auto-lock) ----------
      - conditions:
          - condition: and
            conditions:
              - condition: trigger
                id: sensor_closed
              - condition: template
                value_template: "{{ use_sensor }}"
        sequence:
          # Speak CLOSED immediately
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ do_tts_sensor }}"
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_closed }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_closed }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

          # Guard 1: wait lock_delay unless sensor OPENS -> cancel
          - wait_for_trigger:
              - platform: state
                entity_id: !input door_sensor
                to: "on"
            timeout:
              seconds: !input lock_delay
            continue_on_timeout: true
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait and wait.completed | default(false) }}"
                sequence:
                  - stop: "Door reopened during delay; cancel auto-lock."
            default: []

          # Confirm still closed
          - condition: state
            entity_id: !input door_sensor
            state: "off"

          # Guard 2: optional stability window; cancel if opens
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ (stability | int) > 0 }}"
                sequence:
                  - wait_for_trigger:
                      - platform: state
                        entity_id: !input door_sensor
                        to: "on"
                    timeout:
                      seconds: !input closed_stability
                    continue_on_timeout: true
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ wait and wait.completed | default(false) }}"
                        sequence:
                          - stop: "Door reopened during stability; cancel auto-lock."
                    default: []
            default: []

          # Final re-check + last-moment guard
          - condition: state
            entity_id: !input door_sensor
            state: "off"
          - wait_for_trigger:
              - platform: state
                entity_id: !input door_sensor
                to: "on"
            timeout:
              seconds: 1
            continue_on_timeout: true
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ wait and wait.completed | default(false) }}"
                sequence:
                  - stop: "Door reopened at final guard; cancel auto-lock."
            default: []

          # Only lock if not already locked
          - condition: template
            value_template: "{{ not is_state(lock_ent, 'locked') }}"
          - service: lock.lock
            target: { entity_id: !input lock_entity }

          # Optional: speak lock result
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ use_lock and do_tts_lock }}"
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: "{{ final_locked }}"
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: "{{ final_locked }}"
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

      # ---------- LOCK CHANGED (only locked/unlocked) ----------
      - conditions:
          - condition: and
            conditions:
              - condition: trigger
                id: lock_changed
              - condition: template
                value_template: "{{ use_lock }}"
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: >-
                      {{ do_tts_lock and trigger.to_state.state in ['locked','unlocked'] }}
                sequence:
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ has_voice }}"
                        sequence:
                          - service: tts.speak
                            target: { entity_id: !input tts_engine }
                            data:
                              message: >-
                                {% if trigger.to_state.state == 'locked' %}
                                  {{ final_locked }}
                                {% else %}
                                  {{ final_unlocked }}
                                {% endif %}
                              cache: !input tts_cache
                              media_player_entity_id: !input media_players
                              options: { voice: !input tts_voice }
                    default:
                      - service: tts.speak
                        target: { entity_id: !input tts_engine }
                        data:
                          message: >-
                            {% if trigger.to_state.state == 'locked' %}
                              {{ final_locked }}
                            {% else %}
                              {{ final_unlocked }}
                            {% endif %}
                          cache: !input tts_cache
                          media_player_entity_id: !input media_players
            default: []

blueprint:
  name: Aqara Door/Window Auto-Lock + Announce (Queued)
  description: |-
    ![Aqara](https://www.allthethings.best/wp-content/uploads/2025/05/Aqara-logo-scaled.jpg)

    Auto-lock a smart lock X seconds after the contact sensor reports **CLOSED** (re-checks before locking).
    Optional TTS announcements for **all** state changes of the contact sensor (door/window) and the lock.
    Messages queue (no overlap) because this automation runs in `mode: queued`.
  domain: automation

  input:
    door_sensor:
      name: Contact sensor (door/window)
      description: >
        Pick the contact sensor for THIS door or window.
        For most Aqara sensors, **ON = open** and **OFF = closed**.
        Device class should be `door`, `opening`, or `window`.
      selector:
        entity:
          domain: binary_sensor
          device_class:
            - door
            - opening
            - window

    lock_entity:
      name: Smart lock
      description: "Pick the lock entity to control (Aqara or any `lock.*`)."
      selector:
        entity:
          domain: lock

    lock_delay:
      name: Auto-lock delay (seconds)
      description: "How long after the sensor first reports CLOSED to attempt locking."
      default: 10
      selector:
        number:
          min: 0
          max: 60
          unit_of_measurement: seconds
          mode: slider

    closed_stability:
      name: Closed stability window (seconds)
      description: >
        Extra time the sensor must remain closed (no bounce) before locking.
        Set to 0 to skip. After the main delay we wait this long and re-check closed.
      default: 0
      selector:
        number:
          min: 0
          max: 120
          unit_of_measurement: seconds
          mode: slider

    announce_enabled:
      name: Speak announcements
      description: "Turn on to speak every contact/lock state change."
      default: false
      selector:
        boolean: {}

    announce_sensor:
      name: Announce sensor open/close
      description: "If on, we announce sensor opened/closed events (from your window/door sensor)."
      default: true
      selector:
        boolean: {}

    announce_lock:
      name: Announce lock state changes
      description: "If on, we announce locked/unlocked/locking/unlocking/jammed."
      default: true
      selector:
        boolean: {}

    media_players:
      name: Speakers for TTS
      description: "One or more media_player entities to speak on (used only if announcements are enabled)."
      default: []
      selector:
        entity:
          domain: media_player
          multiple: true

    tts_cache:
      name: Cache TTS audio
      description: "Let Home Assistant cache synthesized speech when supported."
      default: false
      selector:
        boolean: {}

    tts_voice:
      name: Voice name (optional)
      description: >
        If your TTS provider supports a voice option (tts.speak -> options.voice), put it here.
        Leave blank to use the provider's default voice.
      default: ""
      selector:
        text: {}

    custom_open_msg:
      name: Custom message — sensor OPENED (optional)
      description: 'Use {door} placeholder, e.g. "{door} opened." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_closed_msg:
      name: Custom message — sensor CLOSED (optional)
      description: 'Use {door} placeholder, e.g. "{door} closed." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_locked_msg:
      name: Custom message — LOCKED (optional)
      description: 'Use {lock} placeholder, e.g. "{lock} locked." Leave blank for default.'
      default: ""
      selector:
        text: {}

    custom_unlocked_msg:
      name: Custom message — UNLOCKED (optional)
      description: 'Use {lock} placeholder, e.g. "{lock} unlocked." Leave blank for default.'
      default: ""
      selector:
        text: {}

mode: queued
max: 50

trigger:
  # Start the auto-lock timer when the contact first becomes CLOSED.
  - id: sensor_closed
    platform: state
    entity_id: !input door_sensor
    to: "off"

  # Announcements: any contact change
  - id: sensor_changed
    platform: state
    entity_id: !input door_sensor

  # Announcements: any lock change
  - id: lock_changed
    platform: state
    entity_id: !input lock_entity

condition: []

action:
  - variables:
      sensor_entity: !input door_sensor
      lock_entity: !input lock_entity

      # Friendly names
      sensor_name: "{{ state_attr(sensor_entity, 'friendly_name') or sensor_entity }}"
      lock_name: "{{ state_attr(lock_entity, 'friendly_name') or lock_entity }}"

      # Inputs
      announce_enabled: !input announce_enabled
      announce_sensor: !input announce_sensor
      announce_lock: !input announce_lock
      players: !input media_players
      tts_cache: !input tts_cache
      tts_voice: !input tts_voice
      custom_open_msg: !input custom_open_msg
      custom_closed_msg: !input custom_closed_msg
      custom_locked_msg: !input custom_locked_msg
      custom_unlocked_msg: !input custom_unlocked_msg
      closed_stability: !input closed_stability

      # Build a message for the current trigger
      tts_message: >-
        {% if trigger.id == 'sensor_changed' and announce_sensor %}
          {% if is_state(sensor_entity, 'on') %}
            {% set base = (custom_open_msg | default('') | trim) %}
            {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' opened.' }}
          {% else %}
            {% set base = (custom_closed_msg | default('') | trim) %}
            {{ base.replace('{door}', sensor_name) if base else sensor_name ~ ' closed.' }}
          {% endif %}
        {% elif trigger.id == 'lock_changed' and announce_lock %}
          {% set s = trigger.to_state.state %}
          {% if s == 'locked' %}
            {% set base = (custom_locked_msg | default('') | trim) %}
            {{ base.replace('{lock}', lock_name) if base else lock_name ~ ' locked.' }}
          {% elif s == 'unlocked' %}
            {% set base = (custom_unlocked_msg | default('') | trim) %}
            {{ base.replace('{lock}', lock_name) if base else lock_name ~ ' unlocked.' }}
          {% elif s in ['locking','unlocking','jammed'] %}
            {{ lock_name }} is {{ s }}.
          {% else %}
          {% endif %}
        {% else %}{% endif %}

  - choose:

      # ========== AUTO-LOCK PATH ==========
      - conditions:
          - condition: trigger
            id: sensor_closed
        sequence:
          # Wait the primary delay
          - delay:
              seconds: !input lock_delay

          # Check it's still closed
          - condition: state
            entity_id: !input door_sensor
            state: "off"

          # Optional extra "stability" window to avoid bounce
          - delay:
              seconds: !input closed_stability

          # Check again it's still closed
          - condition: state
            entity_id: !input door_sensor
            state: "off"

          # Only lock if not already locked
          - condition: template
            value_template: "{{ not is_state(lock_entity, 'locked') }}"

          - service: lock.lock
            target:
              entity_id: !input lock_entity

          # Optional: speak that we locked
          - if:
              - condition: template
                value_template: >
                  {{ announce_enabled and (players | length > 0) }}
            then:
              - choose:
                  - conditions: "{{ (tts_voice | default('') | trim) != '' }}"
                    sequence:
                      - service: tts.speak
                        data:
                          message: "{{ (custom_locked_msg | trim) and custom_locked_msg.replace('{lock}', lock_name) or (lock_name ~ ' locked.') }}"
                          cache: "{{ tts_cache }}"
                          media_player_entity_id: "{{ players }}"
                          options:
                            voice: "{{ tts_voice }}"
                  - conditions: []
                    sequence:
                      - service: tts.speak
                        data:
                          message: "{{ (custom_locked_msg | trim) and custom_locked_msg.replace('{lock}', lock_name) or (lock_name ~ ' locked.') }}"
                          cache: "{{ tts_cache }}"
                          media_player_entity_id: "{{ players }}"

      # ========== ANNOUNCEMENT PATH ==========
      - conditions:
          - condition: template
            value_template: >
              {{ announce_enabled and (players | length > 0) and (tts_message | default('') | trim | length > 0)
                 and trigger.id in ['sensor_changed','lock_changed'] }}
        sequence:
          - choose:
              - conditions: "{{ (tts_voice | default('') | trim) != '' }}"
                sequence:
                  - service: tts.speak
                    data:
                      message: "{{ tts_message }}"
                      cache: "{{ tts_cache }}"
                      media_player_entity_id: "{{ players }}"
                      options:
                        voice: "{{ tts_voice }}"
              - conditions: []
                sequence:
                  - service: tts.speak
                    data:
                      message: "{{ tts_message }}"
                      cache: "{{ tts_cache }}"
                      media_player_entity_id: "{{ players }}"
